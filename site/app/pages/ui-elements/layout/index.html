<!--
  import {
    PageContainer,
    CodeExample,
    ApiTable,
    ApiItem,
    NoteBlock
  } from '../../../components';
-->
<PageContainer centered _t:title="布局">
  <div class="page-container-section">
    <p>Responsive layouts in material design adapt to any possible screen size. This UI guidance includes a flexible grid that ensures consistency across layouts, breakpoints that detail about how the contents reflow on different screens and a description of how an app can scale from small to extra-large screens.</p>
    <p>By default you can create gutter-free layouts or make the grid system itself calculate the best margin size for each of your possible screen sizes.</p>
    <p>The layout system use the concept of rows and columns. You can create custom sized columns or leave the system to make your layout fluid. You'll be able to set the size for each breakpoint, even on nested columns.</p>
  </div>

  <div class="page-container-section">
    <h2>Breakpoints</h2>
    <p>Jinge Material layout uses breakpoints for responsiveness:</p>
    <ApiTable e:headings="_api.breakpoints.props.headings" e:props="_api.breakpoints.props.props" slot="props" />
  </div>

  <div class="page-container-section">
    <h2>Column Layout</h2>

    <p>The layout system in Jinge Material is essentially based on columns and makes use of the flexbox to be flexible enough and thereby gives you the best experience with a great and easy API.</p>
    <p>What you have to do to get started with layouts is to create a <code>md-layout</code> parent element, that will hold a list of <code>md-layout-item</code>. You can set up as many columns as you want using <code>md-layout-item</code>:</p>
    <CodeExample title="Columns" e:example="_examples.columns" />
  </div>

  <div class="page-container-section">
    <p>By default layout items do not have space between each other. Regular layouts would rather prefer to have spaces between the layout items, like a list of card, for example. You can set Jinge Material to calculate automatically the space between elements and these spaces are based on the screen width, using the breakpoints:</p>
    <ApiTable e:headings="_api.gutter.props.headings" e:props="_api.gutter.props.props" slot="props" />
    <p>Look at this piece of code and resize your browser to see the changes:</p>
    <CodeExample title="Gutter" e:example="_examples.gutter" />
  </div>

  <div class="page-container-section">
    <p>Layout columns also work with nested layouts:</p>
    <CodeExample title="Nested columns" e:example="_examples.nested" />
  </div>

  <div class="page-container-section">
    <p>You can use layouts for almost anything in your app, even for small parts. To help you with that you can have different alignments for <code>md-layout</code> with various combinations of horizontal and vertical alignments to the <code>md-alignment-[horizontal]-[vertical]</code> class, e.g. <code>md-alignment-top-center</code>. The alignment works on the parent element and it will change the position of all the child items:</p>
    <CodeExample title="Alignments" e:example="_examples.alignment" />
  </div>

  <div class="page-container-section">
    <p>In the previous examples the layout system did the calculation of the size of the child items based on the no. of items. But if you want to set size for each item, you can simply set the class, <code>md-size-[amount]</code>, to the item that you want, e.g. <code>md-size-30</code>. The size are always in % and the values can be multiple of 5 and also accepts the values 33 and 66.</p>
    <p>You don't even need to set the size for all elements, as the flexbox model will calculate the size for the remaining items. Cool, uh?</p>
    <CodeExample title="Size" e:example="_examples.sizes" />
  </div>

  <div class="page-container-section">
    <p>A layout system is not good enough if it is not responsive. In the last example you saw fluid layout sizes, but you can change them based on the breakpoint name, by just giving a different class for each breakpoint that you may want. The class is <code>md-[breakpoint]-size-[amount]</code> and works just like the last example. The layout engine of Jinge Material will do the magic. Try to resize your browser:</p>
    <CodeExample title="Responsive" e:example="_examples.responsive" />
  </div>

  <div class="page-container-section">
    <p>Although this is not the best option, it is quite common to hide elements on smaller screen. You can do that using the <code>md-[breakpoint]-hide</code> classes:</p>
    <CodeExample title="Hide Elements" e:example="_examples.hide" />
  </div>

  <ApiItem title="API - md-layout">
    <p slot-pass:default>The following classes can be applied to any HTML Element:</p>

    <ApiTable e:headings="_api.layout.headings" e:props="_api.layout.props" slot-pass:classes />
  </ApiItem>

  <ApiItem title="API - md-layout-item">
    <p slot-pass:default>The following classes can be applied to any HTML Element that are direct children of <code>md-layout</code>:</p>

    <ApiTable e:headings="_api.item.headings" e:props="_api.item.props" slot-pass:classes />
  </ApiItem>

  <ApiItem title="API - md-hide">
    <ApiTable e:headings="_api.hide.headings" e:props="_api.hide.props" slot-pass:classes />
  </ApiItem>
</PageContainer>